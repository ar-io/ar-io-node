#!/usr/bin/env bash

# AR.IO Gateway - Arweave Partition to Height Range Converter
# Converts Arweave storage partition ranges to block height ranges

# Load common library
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/lib/common.sh"

set -euo pipefail

# Check required commands
require_commands curl jq || exit 1

# Constants (Arweave storage module defaults)
DEFAULT_PARTITION_SIZE=3600000000000  # 3.6 TB
DEFAULT_OVERLAP=104857600             # 100 MB
DEFAULT_GATEWAY="https://arweave.net"
DEFAULT_CACHE_DIR="$HOME/.cache/ar-io-node"
DEFAULT_FORMAT="table"

# Configuration variables
PARTITIONS=""
GATEWAY="$DEFAULT_GATEWAY"
PARTITION_SIZE="$DEFAULT_PARTITION_SIZE"
OVERLAP="$DEFAULT_OVERLAP"
CACHE_DIR="$DEFAULT_CACHE_DIR"
FORMAT="$DEFAULT_FORMAT"
USE_CACHE=true
VERBOSE=false

usage() {
  cat <<USAGE
Usage: $0 --partitions RANGE [options]

Convert Arweave storage partition ranges to block height ranges.

Required Arguments:
  --partitions RANGE    Partition range (e.g., "90" or "90-93")

Options:
  --gateway URL         Arweave gateway (default: $DEFAULT_GATEWAY)
  --partition-size N    Override partition size in bytes (default: $DEFAULT_PARTITION_SIZE)
  --overlap N           Override overlap size in bytes (default: $DEFAULT_OVERLAP)
  --cache-dir PATH      Cache directory (default: $DEFAULT_CACHE_DIR)
  --no-cache           Disable caching
  --format FORMAT      Output format: table, json, csv (default: $DEFAULT_FORMAT)
  --verbose            Show detailed progress
  --help               Show this help message

Examples:
  # Single partition
  $0 --partitions 90

  # Range of partitions
  $0 --partitions 90-93

  # Custom gateway with JSON output
  $0 --partitions 90 --gateway https://ar-io.dev --format json

  # Disable cache for fresh data
  $0 --partitions 90 --no-cache

USAGE
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
  case $1 in
    --partitions)
      PARTITIONS="$2"
      shift 2
      ;;
    --gateway)
      GATEWAY="$2"
      shift 2
      ;;
    --partition-size)
      PARTITION_SIZE="$2"
      shift 2
      ;;
    --overlap)
      OVERLAP="$2"
      shift 2
      ;;
    --cache-dir)
      CACHE_DIR="$2"
      shift 2
      ;;
    --no-cache)
      USE_CACHE=false
      shift 1
      ;;
    --format)
      FORMAT="$2"
      shift 2
      ;;
    --verbose)
      VERBOSE=true
      shift 1
      ;;
    --help)
      usage
      exit 0
      ;;
    *)
      echo "Error: Unknown option: $1" >&2
      usage
      exit 1
      ;;
  esac
done

# Validate required arguments
if [[ -z "$PARTITIONS" ]]; then
  echo "Error: --partitions is required" >&2
  usage
  exit 1
fi

# Validate format
if [[ ! "$FORMAT" =~ ^(table|json|csv)$ ]]; then
  echo "Error: Invalid format '$FORMAT'. Must be one of: table, json, csv" >&2
  exit 1
fi

# Validate numeric arguments
for v in "$PARTITION_SIZE" "$OVERLAP"; do
  [[ $v =~ ^[0-9]+$ ]] || { echo "Error: Non-numeric argument detected: $v" >&2; exit 1; }
done

# Parse partition range
if [[ "$PARTITIONS" =~ ^([0-9]+)-([0-9]+)$ ]]; then
  PARTITION_START="${BASH_REMATCH[1]}"
  PARTITION_END="${BASH_REMATCH[2]}"
  if [[ $PARTITION_START -gt $PARTITION_END ]]; then
    echo "Error: Start partition ($PARTITION_START) cannot be greater than end partition ($PARTITION_END)" >&2
    exit 1
  fi
elif [[ "$PARTITIONS" =~ ^([0-9]+)$ ]]; then
  PARTITION_START="${BASH_REMATCH[1]}"
  PARTITION_END="$PARTITION_START"
else
  echo "Error: Invalid partition format '$PARTITIONS'. Use 'N' or 'N-M'" >&2
  exit 1
fi

# Verbose logging function
log_verbose() {
  if [[ "$VERBOSE" == "true" ]]; then
    echo "$@" >&2
  fi
}

# Setup cache directory
CACHE_FILE="$CACHE_DIR/partition-heights.json"
if [[ "$USE_CACHE" == "true" ]]; then
  mkdir -p "$CACHE_DIR"
  if [[ ! -f "$CACHE_FILE" ]]; then
    echo '{"gateway":"","partition_size":0,"blocks":{}}' > "$CACHE_FILE"
  fi
fi

log_verbose "Configuration:"
log_verbose "  Gateway: $GATEWAY"
log_verbose "  Partitions: $PARTITION_START-$PARTITION_END"
log_verbose "  Partition size: $PARTITION_SIZE"
log_verbose "  Overlap: $OVERLAP"
log_verbose "  Cache: $USE_CACHE"
log_verbose "  Format: $FORMAT"
log_verbose ""

# Calculate partition offset boundaries
calculate_partition_offsets() {
  local partition_number=$1
  local start_offset=$((partition_number * PARTITION_SIZE))
  local end_offset=$(((partition_number + 1) * PARTITION_SIZE + OVERLAP))
  echo "$start_offset,$end_offset"
}

# Validate partition offset boundaries
validate_partition_boundaries() {
  local start_offset=$1
  local end_offset=$2

  # Check for arithmetic overflow (basic check)
  if [[ $start_offset -lt 0 || $end_offset -lt 0 ]]; then
    echo "Error: Partition number too large (arithmetic overflow)" >&2
    return 1
  fi

  if [[ $start_offset -ge $end_offset ]]; then
    echo "Error: Invalid partition boundaries: start=$start_offset, end=$end_offset" >&2
    return 1
  fi

  return 0
}

# Make API request with retry logic
api_request() {
  local url="$1"
  local max_retries=5
  local retry_delay=1
  local retry_count=0

  while [[ $retry_count -lt $max_retries ]]; do
    log_verbose "API request: $url (attempt $((retry_count + 1)))"

    if response=$(curl -s --max-time 30 "$url" 2>/dev/null); then
      if [[ -n "$response" && "$response" != "null" ]]; then
        echo "$response"
        return 0
      fi
    fi

    retry_count=$((retry_count + 1))
    if [[ $retry_count -lt $max_retries ]]; then
      log_verbose "Request failed, retrying in ${retry_delay}s..."
      sleep $retry_delay
      retry_delay=$((retry_delay * 2))
    fi
  done

  echo "Error: Failed to fetch data from $url after $max_retries attempts" >&2
  return 1
}

# Get current chain height
get_current_height() {
  local info_response
  if ! info_response=$(api_request "$GATEWAY/info"); then
    return 1
  fi

  local height
  if ! height=$(echo "$info_response" | jq -r '.height // empty' 2>/dev/null); then
    echo "Error: Failed to parse height from gateway response" >&2
    return 1
  fi

  if [[ -z "$height" || "$height" == "null" ]]; then
    echo "Error: Gateway returned invalid height" >&2
    return 1
  fi

  echo "$height"
}

# Get block weave_size for a specific height
get_block_weave_size() {
  local height=$1
  local block_response

  if ! block_response=$(api_request "$GATEWAY/block/height/$height"); then
    return 1
  fi

  local weave_size
  if ! weave_size=$(echo "$block_response" | jq -r '.weave_size // empty' 2>/dev/null); then
    echo "Error: Failed to parse weave_size from block response at height $height" >&2
    return 1
  fi

  if [[ -z "$weave_size" || "$weave_size" == "null" ]]; then
    echo "Error: Block at height $height has no weave_size" >&2
    return 1
  fi

  echo "$weave_size"
}

# Binary search to find height for a given offset
binary_search_height() {
  local target_offset=$1
  local find_type="$2"  # "start" or "end"
  local low=0
  local high

  log_verbose "Binary search for offset $target_offset ($find_type boundary)"

  # Get current chain height
  if ! high=$(get_current_height); then
    echo "Error: Failed to get current chain height" >&2
    return 1
  fi

  log_verbose "Searching between heights $low and $high"

  # Handle special case: offset 0 always maps to height 0
  if [[ $target_offset -eq 0 ]]; then
    echo "0"
    return 0
  fi

  # Binary search for the appropriate height
  while [[ $low -le $high ]]; do
    local mid=$(( (low + high) / 2 ))
    local weave_size

    log_verbose "Checking height $mid (low=$low, high=$high)"

    if ! weave_size=$(get_block_weave_size_cached "$mid"); then
      echo "Error: Failed to get weave_size for height $mid" >&2
      return 1
    fi

    log_verbose "Height $mid has weave_size $weave_size"

    # Add small delay to avoid overwhelming the API
    sleep 0.1

    if [[ "$find_type" == "start" ]]; then
      # Looking for first block where weave_size >= target_offset
      if [[ $weave_size -ge $target_offset ]]; then
        # Found a candidate, check if previous block is < target_offset
        if [[ $mid -eq 0 ]]; then
          echo "$mid"
          return 0
        fi

        local prev_weave_size
        if ! prev_weave_size=$(get_block_weave_size_cached $((mid - 1))); then
          echo "Error: Failed to get weave_size for height $((mid - 1))" >&2
          return 1
        fi

        if [[ $prev_weave_size -lt $target_offset ]]; then
          echo "$mid"
          return 0
        else
          high=$((mid - 1))
        fi
      else
        low=$((mid + 1))
      fi
    else
      # Looking for last block where weave_size <= target_offset
      if [[ $weave_size -le $target_offset ]]; then
        # Found a candidate, check if next block is > target_offset
        local next_weave_size
        if ! next_weave_size=$(get_block_weave_size_cached $((mid + 1))); then
          # If we can't get the next block, this might be the end of the chain
          echo "$mid"
          return 0
        fi

        if [[ $next_weave_size -gt $target_offset ]]; then
          echo "$mid"
          return 0
        else
          low=$((mid + 1))
        fi
      else
        high=$((mid - 1))
      fi
    fi
  done

  # If we exit the loop without finding a result, handle edge cases
  if [[ "$find_type" == "start" ]]; then
    # Return the lowest height that has any data
    echo "$low"
  else
    # Return the highest height we found with data <= target
    echo "$high"
  fi
}

# Cache management functions
get_cached_weave_size() {
  local height=$1

  if [[ "$USE_CACHE" != "true" || ! -f "$CACHE_FILE" ]]; then
    return 1
  fi

  local cached_data
  if ! cached_data=$(jq -r ".blocks[\"$height\"] // empty" "$CACHE_FILE" 2>/dev/null); then
    return 1
  fi

  if [[ -z "$cached_data" || "$cached_data" == "null" ]]; then
    return 1
  fi

  # Extract weave_size from cached data
  local weave_size
  if ! weave_size=$(echo "$cached_data" | jq -r '.weave_size // empty' 2>/dev/null); then
    return 1
  fi

  if [[ -z "$weave_size" || "$weave_size" == "null" ]]; then
    return 1
  fi

  echo "$weave_size"
  return 0
}

cache_weave_size() {
  local height=$1
  local weave_size=$2

  if [[ "$USE_CACHE" != "true" ]]; then
    return 0
  fi

  local timestamp=$(date +%s)
  local temp_file="${CACHE_FILE}.tmp"

  # Update cache file with new entry
  jq --arg height "$height" \
     --arg weave_size "$weave_size" \
     --arg timestamp "$timestamp" \
     --arg gateway "$GATEWAY" \
     --arg partition_size "$PARTITION_SIZE" \
     '.gateway = $gateway |
      .partition_size = ($partition_size | tonumber) |
      .blocks[$height] = {
        "weave_size": $weave_size,
        "timestamp": ($timestamp | tonumber)
      }' \
     "$CACHE_FILE" > "$temp_file" && mv "$temp_file" "$CACHE_FILE"
}

# Enhanced get_block_weave_size with caching
get_block_weave_size_cached() {
  local height=$1

  # Try cache first
  local cached_weave_size
  if cached_weave_size=$(get_cached_weave_size "$height"); then
    log_verbose "Cache hit for height $height: $cached_weave_size"
    echo "$cached_weave_size"
    return 0
  fi

  # Cache miss, fetch from API
  log_verbose "Cache miss for height $height, fetching from API"
  local weave_size
  if ! weave_size=$(get_block_weave_size "$height"); then
    return 1
  fi

  # Cache the result
  cache_weave_size "$height" "$weave_size"
  echo "$weave_size"
  return 0
}

# Output formatting functions
format_table_output() {
  local partition_data="$1"

  printf "%-9s | %-19s | %-19s | %-12s | %-10s | %-6s\n" \
    "Partition" "Start Offset" "End Offset" "Start Height" "End Height" "Blocks"
  printf "%-9s-+-%-19s-+-%-19s-+-%-12s-+-%-10s-+-%-6s\n" \
    "---------" "-------------------" "-------------------" "------------" "----------" "------"

  echo "$partition_data" | while IFS=',' read -r partition start_offset end_offset start_height end_height block_count; do
    # Handle empty partitions
    if [[ "$start_height" == "N/A" ]]; then
      printf "%-9s | %-19s | %-19s | %-12s | %-10s | %-6s\n" \
        "$partition" "$start_offset" "$end_offset" "No data" "No data" "0"
    else
      printf "%-9s | %-19s | %-19s | %-12s | %-10s | %-6s\n" \
        "$partition" "$start_offset" "$end_offset" "$start_height" "$end_height" "$block_count"
    fi
  done
}

format_csv_output() {
  local partition_data="$1"

  echo "partition,start_offset,end_offset,start_height,end_height,block_count"
  echo "$partition_data" | while IFS=',' read -r partition start_offset end_offset start_height end_height block_count; do
    echo "$partition,$start_offset,$end_offset,$start_height,$end_height,$block_count"
  done
}

format_json_output() {
  local partition_data="$1"

  echo "{"
  echo "  \"partitions\": ["

  local first=true
  echo "$partition_data" | while IFS=',' read -r partition start_offset end_offset start_height end_height block_count; do
    if [[ "$first" != "true" ]]; then
      echo ","
    else
      first=false
    fi

    echo -n "    {"
    echo -n "\"partition\": $partition, "
    echo -n "\"start_offset\": \"$start_offset\", "
    echo -n "\"end_offset\": \"$end_offset\", "

    if [[ "$start_height" == "N/A" ]]; then
      echo -n "\"start_height\": null, "
      echo -n "\"end_height\": null, "
      echo -n "\"block_count\": 0"
    else
      echo -n "\"start_height\": $start_height, "
      echo -n "\"end_height\": $end_height, "
      echo -n "\"block_count\": $block_count"
    fi
    echo -n "}"
  done

  echo ""
  echo "  ]"
  echo "}"
}

# Process a single partition
process_partition() {
  local partition_number=$1
  local offsets start_offset end_offset

  log_verbose "Processing partition $partition_number"

  # Calculate offset boundaries
  if ! offsets=$(calculate_partition_offsets "$partition_number"); then
    echo "Error: Failed to calculate offsets for partition $partition_number" >&2
    return 1
  fi

  start_offset=$(echo "$offsets" | cut -d',' -f1)
  end_offset=$(echo "$offsets" | cut -d',' -f2)

  # Validate boundaries
  if ! validate_partition_boundaries "$start_offset" "$end_offset"; then
    return 1
  fi

  log_verbose "Partition $partition_number spans offsets $start_offset to $end_offset"

  # Find corresponding heights
  local start_height end_height

  # Check if partition is beyond current chain data
  local current_height
  if ! current_height=$(get_current_height); then
    echo "Error: Failed to get current chain height" >&2
    return 1
  fi

  # Get the weave size at current height to check if partition has data
  local current_weave_size
  if ! current_weave_size=$(get_block_weave_size_cached "$current_height"); then
    echo "Error: Failed to get current weave size" >&2
    return 1
  fi

  # Check if partition start is beyond current chain data
  if [[ $start_offset -gt $current_weave_size ]]; then
    log_verbose "Partition $partition_number is beyond current chain data"
    echo "$partition_number,$start_offset,$end_offset,N/A,N/A,0"
    return 0
  fi

  # Find start height
  if ! start_height=$(binary_search_height "$start_offset" "start"); then
    echo "Error: Failed to find start height for offset $start_offset" >&2
    return 1
  fi

  # Find end height
  if ! end_height=$(binary_search_height "$end_offset" "end"); then
    echo "Error: Failed to find end height for offset $end_offset" >&2
    return 1
  fi

  # Calculate block count
  local block_count=$((end_height - start_height + 1))

  log_verbose "Partition $partition_number: heights $start_height to $end_height ($block_count blocks)"

  echo "$partition_number,$start_offset,$end_offset,$start_height,$end_height,$block_count"
}

# Main execution
main() {
  local partition_data=""

  log_verbose "Processing partitions $PARTITION_START to $PARTITION_END"

  # Process each partition in the range
  for ((partition = PARTITION_START; partition <= PARTITION_END; partition++)); do
    local result
    if ! result=$(process_partition "$partition"); then
      echo "Error: Failed to process partition $partition" >&2
      exit 1
    fi

    if [[ -n "$partition_data" ]]; then
      partition_data="$partition_data"$'\n'"$result"
    else
      partition_data="$result"
    fi
  done

  # Format and output results
  case "$FORMAT" in
    table)
      format_table_output "$partition_data"
      ;;
    csv)
      format_csv_output "$partition_data"
      ;;
    json)
      format_json_output "$partition_data"
      ;;
    *)
      echo "Error: Unknown format: $FORMAT" >&2
      exit 1
      ;;
  esac
}

# Run the main function
main