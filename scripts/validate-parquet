#!/usr/bin/env bash

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Default paths
CORE_DB_DEFAULT="data/sqlite/core.db"
BUNDLES_DB_DEFAULT="data/sqlite/bundles.db"
PARQUET_DIR_1_DEFAULT="data/parquet-ts"
PARQUET_DIR_2_DEFAULT="data/parquet-bash"
OUTPUT_DIR_DEFAULT="data/validation-results"

# Script variables
CORE_DB="$CORE_DB_DEFAULT"
BUNDLES_DB="$BUNDLES_DB_DEFAULT"
PARQUET_DIR_1="$PARQUET_DIR_1_DEFAULT"
PARQUET_DIR_2="$PARQUET_DIR_2_DEFAULT"
OUTPUT_DIR="$OUTPUT_DIR_DEFAULT"
MODE="full"
START_HEIGHT=""
END_HEIGHT=""
QUICK_MODE=false
VERBOSE=false
SAMPLE_RATE=0.01  # 1% sample by default
TIMESTAMP=$(date +"%Y%m%d-%H%M%S")
TEMP_DB=""
LOG_FILE=""

usage() {
  cat <<USAGE
Usage: $0 [options]

Validates Parquet exports against source SQLite databases and compares different export methods.

Options:
  --mode MODE              Validation mode: 'source', 'compare', or 'full' (default: full)
  --core-db PATH           Path to core SQLite database (default: $CORE_DB_DEFAULT)
  --bundles-db PATH        Path to bundles SQLite database (default: $BUNDLES_DB_DEFAULT)
  --dir1 PATH              First Parquet directory (default: $PARQUET_DIR_1_DEFAULT)
  --dir2 PATH              Second Parquet directory (default: $PARQUET_DIR_2_DEFAULT)
  --output-dir PATH        Output directory for reports (default: $OUTPUT_DIR_DEFAULT)
  --start-height N         Start height for validation range
  --end-height N           End height for validation range
  --quick                  Quick validation (metadata only, no data comparison)
  --verbose                Verbose output with detailed logging
  --sample-rate RATE       Sample rate for data comparison (0.0-1.0, default: 0.01)
  -h, --help              Show this help message

Modes:
  source    - Validate Parquet exports against SQLite source databases only
  compare   - Compare two Parquet exports against each other only
  full      - Perform both source and cross-export validation (default)

Examples:
  # Full validation with defaults
  $0

  # Validate single export against source
  $0 --mode source --dir1 data/parquet-ts

  # Compare two exports
  $0 --mode compare --dir1 data/parquet-ts --dir2 data/parquet-bash

  # Quick check of specific height range
  $0 --quick --start-height 900000 --end-height 910000
USAGE
}

log() {
  local level="$1"
  shift
  local message="$*"
  local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
  
  case "$level" in
    "INFO")
      echo -e "${GREEN}✓${NC} $message"
      ;;
    "WARN")
      echo -e "${YELLOW}⚠${NC} $message"
      ;;
    "ERROR")
      echo -e "${RED}✗${NC} $message"
      ;;
    "DEBUG")
      if [[ "$VERBOSE" == "true" ]]; then
        echo -e "${BLUE}ℹ${NC} $message"
      fi
      ;;
  esac
  
  if [[ -n "$LOG_FILE" ]]; then
    echo "[$timestamp] [$level] $message" >> "$LOG_FILE"
  fi
}

check_dependencies() {
  log "DEBUG" "Checking dependencies..."
  
  if ! command -v duckdb >/dev/null 2>&1; then
    log "ERROR" "duckdb CLI is required but not found in PATH"
    exit 2
  fi
  
  log "DEBUG" "All dependencies satisfied"
}

setup_workspace() {
  mkdir -p "$OUTPUT_DIR"
  
  TEMP_DB="$(mktemp -u /tmp/parquet_validation_XXXX.duckdb)"
  LOG_FILE="$OUTPUT_DIR/validation-$TIMESTAMP.log"
  
  log "DEBUG" "Workspace setup complete"
  log "DEBUG" "Temp database: $TEMP_DB"
  log "DEBUG" "Log file: $LOG_FILE"
}

cleanup() {
  if [[ -n "$TEMP_DB" && -f "$TEMP_DB" ]]; then
    rm -f "$TEMP_DB" "$TEMP_DB.wal"
  fi
}

validate_inputs() {
  local errors=0
  
  if [[ "$MODE" == "source" || "$MODE" == "full" ]]; then
    if [[ ! -f "$CORE_DB" ]]; then
      log "ERROR" "Core database not found: $CORE_DB"
      ((errors++))
    fi
    
    if [[ ! -f "$BUNDLES_DB" ]]; then
      log "ERROR" "Bundles database not found: $BUNDLES_DB"
      ((errors++))
    fi
  fi
  
  if [[ "$MODE" == "source" || "$MODE" == "full" ]]; then
    if [[ ! -d "$PARQUET_DIR_1" ]]; then
      log "ERROR" "Parquet directory 1 not found: $PARQUET_DIR_1"
      ((errors++))
    fi
  fi
  
  if [[ "$MODE" == "compare" || "$MODE" == "full" ]]; then
    if [[ ! -d "$PARQUET_DIR_1" ]]; then
      log "ERROR" "Parquet directory 1 not found: $PARQUET_DIR_1"
      ((errors++))
    fi
    
    if [[ ! -d "$PARQUET_DIR_2" ]]; then
      log "ERROR" "Parquet directory 2 not found: $PARQUET_DIR_2"
      ((errors++))
    fi
  fi
  
  if [[ -n "$START_HEIGHT" && -n "$END_HEIGHT" ]]; then
    if ! [[ "$START_HEIGHT" =~ ^[0-9]+$ ]] || ! [[ "$END_HEIGHT" =~ ^[0-9]+$ ]]; then
      log "ERROR" "Height values must be numeric"
      ((errors++))
    elif (( START_HEIGHT > END_HEIGHT )); then
      log "ERROR" "Start height cannot be greater than end height"
      ((errors++))
    fi
  fi
  
  if [[ "$errors" -gt 0 ]]; then
    log "ERROR" "Validation failed with $errors error(s)"
    exit 2
  fi
}

setup_duckdb() {
  log "DEBUG" "Setting up DuckDB environment..."
  
  # Create database and load schema
  cat > /tmp/schema_setup.sql <<EOF
-- Load required extensions
INSTALL sqlite;
LOAD sqlite;

-- Create schema
CREATE TABLE IF NOT EXISTS tags (
  height UBIGINT NOT NULL,
  id BLOB NOT NULL,
  tag_index USMALLINT NOT NULL,
  indexed_at UBIGINT,
  tag_name BLOB NOT NULL,
  tag_value BLOB NOT NULL,
  is_data_item BOOLEAN NOT NULL
);

CREATE TABLE IF NOT EXISTS transactions (
  id BLOB NOT NULL,
  indexed_at UBIGINT,
  block_transaction_index USMALLINT,
  is_data_item BOOLEAN,
  target BLOB,
  quantity DECIMAL(20,0),
  reward DECIMAL(20,0),
  anchor BLOB NOT NULL,
  data_size UBIGINT,
  content_type TEXT,
  format UTINYINT,
  height UBIGINT NOT NULL,
  owner_address BLOB,
  data_root BLOB,
  parent BLOB,
  "offset" UBIGINT,
  size UBIGINT,
  data_offset UBIGINT,
  owner_offset UBIGINT,
  owner_size UINTEGER,
  owner BLOB,
  signature_offset UBIGINT,
  signature_size UINTEGER,
  signature_type UINTEGER,
  root_transaction_id BLOB,
  root_parent_offset UINTEGER
);

CREATE TABLE IF NOT EXISTS blocks (
  indep_hash BLOB,
  height UBIGINT NOT NULL,
  previous_block BLOB,
  nonce BLOB NOT NULL,
  hash BLOB NOT NULL,
  block_timestamp INTEGER NOT NULL,
  tx_count INTEGER NOT NULL,
  block_size UBIGINT
);
EOF

  duckdb "$TEMP_DB" < /tmp/schema_setup.sql
  rm -f /tmp/schema_setup.sql
  
  # Attach SQLite databases if needed
  if [[ "$MODE" == "source" || "$MODE" == "full" ]]; then
    duckdb "$TEMP_DB" -c "
      ATTACH '$CORE_DB' AS core (TYPE SQLITE, READONLY, BUSY_TIMEOUT 30000);
      ATTACH '$BUNDLES_DB' AS bundles (TYPE SQLITE, READONLY, BUSY_TIMEOUT 30000);
    "
  fi
  
  log "DEBUG" "DuckDB environment ready"
}

get_height_range() {
  local parquet_dir="$1"
  local files=($(find "$parquet_dir" -name "*.parquet" -type f | head -1))
  
  if [[ ${#files[@]} -eq 0 ]]; then
    echo "0 0"
    return
  fi
  
  local filename=$(basename "${files[0]}")
  local min_height=$(echo "$filename" | sed -n 's/.*minHeight:\([0-9]*\).*/\1/p')
  local max_height=$(echo "$filename" | sed -n 's/.*maxHeight:\([0-9]*\).*/\1/p')
  
  # Get all files to find actual range
  local all_files=($(find "$parquet_dir" -name "*.parquet" -type f))
  local global_min=""
  local global_max=""
  
  for file in "${all_files[@]}"; do
    local fname=$(basename "$file")
    local min=$(echo "$fname" | sed -n 's/.*minHeight:\([0-9]*\).*/\1/p')
    local max=$(echo "$fname" | sed -n 's/.*maxHeight:\([0-9]*\).*/\1/p')
    
    if [[ -z "$global_min" || "$min" -lt "$global_min" ]]; then
      global_min="$min"
    fi
    
    if [[ -z "$global_max" || "$max" -gt "$global_max" ]]; then
      global_max="$max"
    fi
  done
  
  echo "${global_min:-0} ${global_max:-0}"
}

catalog_parquet_files() {
  local parquet_dir="$1"
  local prefix="$2"
  
  log "DEBUG" "Cataloging Parquet files in $parquet_dir"
  
  local blocks_files=($(find "$parquet_dir" -name "blocks-*.parquet" -type f | sort))
  local transactions_files=($(find "$parquet_dir" -name "transactions-*.parquet" -type f | sort))
  local tags_files=($(find "$parquet_dir" -name "tags-*.parquet" -type f | sort))
  
  local total_files=$((${#blocks_files[@]} + ${#transactions_files[@]} + ${#tags_files[@]}))
  
  if [[ "$total_files" -eq 0 ]]; then
    log "WARN" "No Parquet files found in $parquet_dir"
    return 1
  fi
  
  local range=($(get_height_range "$parquet_dir"))
  local min_height="${range[0]}"
  local max_height="${range[1]}"
  
  echo "  ${prefix}Directory: $parquet_dir"
  echo "  ${prefix}Files: $total_files (${#blocks_files[@]} blocks, ${#transactions_files[@]} transactions, ${#tags_files[@]} tags)"
  echo "  ${prefix}Height range: $min_height-$max_height"
  
  return 0
}

validate_against_source() {
  local parquet_dir="$1"
  local validation_passed=true
  
  echo
  echo "=== SOURCE DATABASE VALIDATION ==="
  
  log "INFO" "Core DB: $CORE_DB (accessible)"
  log "INFO" "Bundles DB: $BUNDLES_DB (accessible)"
  
  echo
  echo "Parquet Export:"
  catalog_parquet_files "$parquet_dir" "  "
  
  echo
  echo "Data Validation:"
  
  # Validate blocks
  echo -n "  Blocks: "
  if validate_table_against_source "blocks" "$parquet_dir"; then
    log "INFO" "Row count and sample data match"
  else
    log "ERROR" "Validation failed"
    validation_passed=false
  fi
  
  # Validate transactions
  echo -n "  Transactions: "
  if validate_table_against_source "transactions" "$parquet_dir"; then
    log "INFO" "Row count and sample data match"
  else
    log "ERROR" "Validation failed"
    validation_passed=false
  fi
  
  # Validate tags
  echo -n "  Tags: "
  if validate_table_against_source "tags" "$parquet_dir"; then
    log "INFO" "Row count and sample data match"
  else
    log "ERROR" "Validation failed"
    validation_passed=false
  fi
  
  return $([[ "$validation_passed" == "true" ]] && echo 0 || echo 1)
}

validate_table_against_source() {
  local table="$1"
  local parquet_dir="$2"
  local height_filter=""
  
  if [[ -n "$START_HEIGHT" && -n "$END_HEIGHT" ]]; then
    height_filter="WHERE height BETWEEN $START_HEIGHT AND $END_HEIGHT"
  fi
  
  # Load Parquet files for this table
  local parquet_files=($(find "$parquet_dir" -name "${table}-*.parquet" -type f))
  
  if [[ ${#parquet_files[@]} -eq 0 ]]; then
    log "ERROR" "No Parquet files found for table $table"
    return 1
  fi
  
  # Create view for Parquet data
  local parquet_view="${table}_parquet"
  duckdb "$TEMP_DB" -c "
    CREATE OR REPLACE VIEW $parquet_view AS
    SELECT * FROM read_parquet(['$(IFS=,; echo "${parquet_files[*]}")'])
    $height_filter;
  "
  
  # Get row counts
  local sqlite_count parquet_count
  
  case "$table" in
    "blocks")
      sqlite_count=$(duckdb "$TEMP_DB" -csv -noheader -c "
        SELECT COUNT(*) FROM core.stable_blocks $height_filter;
      ")
      ;;
    "transactions")
      sqlite_count=$(duckdb "$TEMP_DB" -csv -noheader -c "
        SELECT COUNT(*) FROM (
          SELECT id FROM core.stable_transactions $height_filter
          UNION ALL
          SELECT id FROM bundles.stable_data_items $height_filter
        );
      ")
      ;;
    "tags")
      sqlite_count=$(duckdb "$TEMP_DB" -csv -noheader -c "
        SELECT COUNT(*) FROM (
          SELECT st.height FROM core.stable_transactions st
          CROSS JOIN core.stable_transaction_tags stt
          WHERE st.id = stt.transaction_id $([[ -n "$height_filter" ]] && echo "AND st.height BETWEEN $START_HEIGHT AND $END_HEIGHT")
          UNION ALL
          SELECT sdi.height FROM bundles.stable_data_items sdi
          CROSS JOIN bundles.stable_data_item_tags sdit
          WHERE sdi.id = sdit.data_item_id $([[ -n "$height_filter" ]] && echo "AND sdi.height BETWEEN $START_HEIGHT AND $END_HEIGHT")
        );
      ")
      ;;
  esac
  
  parquet_count=$(duckdb "$TEMP_DB" -csv -noheader -c "
    SELECT COUNT(*) FROM $parquet_view;
  ")
  
  log "DEBUG" "$table - SQLite: $sqlite_count, Parquet: $parquet_count"
  
  if [[ "$sqlite_count" != "$parquet_count" ]]; then
    log "ERROR" "Row count mismatch: SQLite ($sqlite_count) != Parquet ($parquet_count)"
    return 1
  fi
  
  # Skip data sampling in quick mode
  if [[ "$QUICK_MODE" == "true" ]]; then
    return 0
  fi
  
  # Sample data comparison
  local sample_size=$(echo "$parquet_count * $SAMPLE_RATE" | bc -l | cut -d. -f1)
  if [[ "$sample_size" -lt 1 ]]; then
    sample_size=1
  fi
  
  log "DEBUG" "Sampling $sample_size rows for data comparison"
  
  # This is a simplified check - in practice, you'd want more sophisticated sampling
  local parquet_sample_hash sqlite_sample_hash
  
  parquet_sample_hash=$(duckdb "$TEMP_DB" -csv -noheader -c "
    SELECT hash(string_agg(CAST(height AS VARCHAR), '|' ORDER BY height))
    FROM (SELECT DISTINCT height FROM $parquet_view ORDER BY height LIMIT $sample_size);
  ")
  
  case "$table" in
    "blocks")
      sqlite_sample_hash=$(duckdb "$TEMP_DB" -csv -noheader -c "
        SELECT hash(string_agg(CAST(height AS VARCHAR), '|' ORDER BY height))
        FROM (SELECT DISTINCT height FROM core.stable_blocks $height_filter ORDER BY height LIMIT $sample_size);
      ")
      ;;
    "transactions"|"tags")
      # For transactions and tags, this is more complex due to the union
      # For now, just check that we have the expected height range
      return 0
      ;;
  esac
  
  if [[ "$table" == "blocks" && "$parquet_sample_hash" != "$sqlite_sample_hash" ]]; then
    log "ERROR" "Sample data hash mismatch"
    return 1
  fi
  
  return 0
}

compare_parquet_exports() {
  local dir1="$1"
  local dir2="$2"
  local comparison_passed=true
  
  echo
  echo "=== CROSS-EXPORT COMPARISON ==="
  
  echo "Directory 1:"
  catalog_parquet_files "$dir1" "  "
  
  echo
  echo "Directory 2:"
  catalog_parquet_files "$dir2" "  "
  
  echo
  echo "Comparison Results:"
  
  # Compare file structures
  local files1=($(find "$dir1" -name "*.parquet" -type f | sort | xargs -I {} basename {}))
  local files2=($(find "$dir2" -name "*.parquet" -type f | sort | xargs -I {} basename {}))
  
  if [[ "${#files1[@]}" != "${#files2[@]}" ]]; then
    log "ERROR" "File count mismatch: ${#files1[@]} vs ${#files2[@]}"
    comparison_passed=false
  else
    log "INFO" "File count matches: ${#files1[@]} files"
  fi
  
  # Check file names match
  local missing_files=()
  for file in "${files1[@]}"; do
    if [[ ! " ${files2[*]} " =~ " ${file} " ]]; then
      missing_files+=("$file")
    fi
  done
  
  if [[ ${#missing_files[@]} -gt 0 ]]; then
    log "ERROR" "Files missing in directory 2: ${missing_files[*]}"
    comparison_passed=false
  else
    log "INFO" "File names match"
  fi
  
  if [[ "$QUICK_MODE" == "true" ]]; then
    return $([[ "$comparison_passed" == "true" ]] && echo 0 || echo 1)
  fi
  
  # Compare data content
  for table in "blocks" "transactions" "tags"; do
    echo -n "  $table: "
    if compare_table_data "$table" "$dir1" "$dir2"; then
      log "INFO" "Data matches"
    else
      log "ERROR" "Data mismatch"
      comparison_passed=false
    fi
  done
  
  return $([[ "$comparison_passed" == "true" ]] && echo 0 || echo 1)
}

compare_table_data() {
  local table="$1"
  local dir1="$2"
  local dir2="$3"
  
  local files1=($(find "$dir1" -name "${table}-*.parquet" -type f | sort))
  local files2=($(find "$dir2" -name "${table}-*.parquet" -type f | sort))
  
  if [[ ${#files1[@]} -eq 0 || ${#files2[@]} -eq 0 ]]; then
    return 1
  fi
  
  # Create views for both datasets
  duckdb "$TEMP_DB" -c "
    CREATE OR REPLACE VIEW ${table}_1 AS
    SELECT * FROM read_parquet(['$(IFS=,; echo "${files1[*]}")']);
    
    CREATE OR REPLACE VIEW ${table}_2 AS
    SELECT * FROM read_parquet(['$(IFS=,; echo "${files2[*]}")']);
  "
  
  # Compare row counts
  local count1 count2
  count1=$(duckdb "$TEMP_DB" -csv -noheader -c "SELECT COUNT(*) FROM ${table}_1;")
  count2=$(duckdb "$TEMP_DB" -csv -noheader -c "SELECT COUNT(*) FROM ${table}_2;")
  
  if [[ "$count1" != "$count2" ]]; then
    log "DEBUG" "$table row count mismatch: $count1 vs $count2"
    return 1
  fi
  
  # Compare data hashes (simplified check)
  local hash1 hash2
  hash1=$(duckdb "$TEMP_DB" -csv -noheader -c "
    SELECT hash(string_agg(CAST(height AS VARCHAR), '|' ORDER BY height))
    FROM (SELECT DISTINCT height FROM ${table}_1 ORDER BY height);
  ")
  hash2=$(duckdb "$TEMP_DB" -csv -noheader -c "
    SELECT hash(string_agg(CAST(height AS VARCHAR), '|' ORDER BY height))
    FROM (SELECT DISTINCT height FROM ${table}_2 ORDER BY height);
  ")
  
  if [[ "$hash1" != "$hash2" ]]; then
    log "DEBUG" "$table data hash mismatch"
    return 1
  fi
  
  return 0
}

generate_report() {
  local overall_status="$1"
  
  echo
  echo "=== VALIDATION SUMMARY ==="
  
  if [[ "$overall_status" -eq 0 ]]; then
    log "INFO" "All validations PASSED"
  else
    log "ERROR" "Validation FAILED"
  fi
  
  echo
  echo "Report details saved to: $LOG_FILE"
  
  # Generate JSON summary
  local json_report="$OUTPUT_DIR/report-$TIMESTAMP.json"
  cat > "$json_report" <<EOF
{
  "timestamp": "$TIMESTAMP",
  "mode": "$MODE",
  "status": $([ "$overall_status" -eq 0 ] && echo '"PASSED"' || echo '"FAILED"'),
  "configuration": {
    "core_db": "$CORE_DB",
    "bundles_db": "$BUNDLES_DB",
    "parquet_dir_1": "$PARQUET_DIR_1",
    "parquet_dir_2": "$PARQUET_DIR_2",
    "height_range": {
      "start": ${START_HEIGHT:-null},
      "end": ${END_HEIGHT:-null}
    },
    "quick_mode": $QUICK_MODE,
    "sample_rate": $SAMPLE_RATE
  }
}
EOF
  
  echo "JSON report: $json_report"
}

main() {
  local overall_status=0
  
  echo "=== PARQUET VALIDATION REPORT ==="
  echo "Timestamp: $(date)"
  echo "Mode: $MODE"
  
  check_dependencies
  validate_inputs
  setup_workspace
  setup_duckdb
  
  if [[ "$MODE" == "source" || "$MODE" == "full" ]]; then
    if ! validate_against_source "$PARQUET_DIR_1"; then
      overall_status=1
    fi
  fi
  
  if [[ "$MODE" == "compare" || "$MODE" == "full" ]]; then
    if ! compare_parquet_exports "$PARQUET_DIR_1" "$PARQUET_DIR_2"; then
      overall_status=1
    fi
  fi
  
  generate_report "$overall_status"
  
  cleanup
  exit "$overall_status"
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
  case $1 in
    --mode)
      MODE="$2"
      if [[ ! "$MODE" =~ ^(source|compare|full)$ ]]; then
        echo "Error: Invalid mode '$MODE'. Must be 'source', 'compare', or 'full'." >&2
        exit 2
      fi
      shift 2
      ;;
    --core-db)
      CORE_DB="$2"
      shift 2
      ;;
    --bundles-db)
      BUNDLES_DB="$2"
      shift 2
      ;;
    --dir1)
      PARQUET_DIR_1="$2"
      shift 2
      ;;
    --dir2)
      PARQUET_DIR_2="$2"
      shift 2
      ;;
    --output-dir)
      OUTPUT_DIR="$2"
      shift 2
      ;;
    --start-height)
      START_HEIGHT="$2"
      shift 2
      ;;
    --end-height)
      END_HEIGHT="$2"
      shift 2
      ;;
    --quick)
      QUICK_MODE=true
      shift 1
      ;;
    --verbose)
      VERBOSE=true
      shift 1
      ;;
    --sample-rate)
      SAMPLE_RATE="$2"
      shift 2
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    *)
      echo "Unknown option: $1" >&2
      usage
      exit 2
      ;;
  esac
done

# Set up trap for cleanup
trap cleanup EXIT

# Run main function
main